# 3.list

# 1.基本概念

List容器是一个双向链表。

链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

链表由一系列**结点**（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，**list对于空间的运用有绝对的精准，一点也不浪费**。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。

List和vector是两个最常被使用的容器。

![](image/2a8-7tu0xx_uAxltcZTNd.png)

# 2.迭代器

List容器不能像vector一样以普通指针作为迭代器，因为其节点不能保证在同一块连续的内存空间上。

List迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取操作。所谓”list正确的递增，递减、取值、成员取用”是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的数据值，成员取用时取的是节点的成员。

由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是`Bidirectional Iterators`。

List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。

# 3.常用API

## 3.1 构造函数

```c++
// list采用采用模板类实现,对象的默认构造形式：
std::list<T> lstT;
// 构造函数将[beg, end)区间中的元素拷贝给本身。
std::list(beg,end);
// 构造函数将n个elem拷贝给本身。
std::list(n,elem);
// 拷贝构造函数。
std::list(const list &lst);
```

## 3.2 插入和删除

```c++
// 在容器尾部加入一个元素
push_back(elem);
// 删除容器中最后一个元素
pop_back();
// 在容器开头插入一个元素
push_front(elem);
// 从容器开头移除第一个元素
pop_front();
// 在pos位置插elem元素的拷贝，返回新数据的位置。
insert(pos,elem);
// 在pos位置插入n个elem数据，无返回值。
insert(pos,n,elem);
// 在pos位置插入[beg,end)区间的数据，无返回值。
insert(pos,beg,end);
// 移除容器的所有数据
clear();
// 删除[beg,end)区间的数据，返回下一个数据的位置。
erase(beg,end);
// 删除pos位置的数据，返回下一个数据的位置。
erase(pos);
// 删除容器中所有与elem值匹配的元素。
remove(elem);
```

## 3.3 大小操作

```c++
// 返回容器中元素的个数
size();
// 判断容器是否为空
empty();
// 重新指定容器的长度为num，
// 若容器变长，则以默认值填充新位置。
// 如果容器变短，则末尾超出容器长度的元素被删除。
resize(num);
// 重新指定容器的长度为num，
// 若容器变长，则以elem值填充新位置。
// 如果容器变短，则末尾超出容器长度的元素被删除。
resize(num, elem);
```

## 3.4 赋值操作

```c++
// 将[beg, end)区间中的数据拷贝赋值给本身。
assign(beg, end);
// 将n个elem拷贝赋值给本身。
assign(n, elem);
// 重载等号操作符
list& operator=(const list &lst);
// 将lst与本身的元素互换。
swap(lst);
```

## 3.5 数据的存取

```c++
// 返回第一个元素。
front();
// 返回最后一个元素。
back();
```

## 3.6 反转排序

```c++
// 反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。
reverse();
// list排序
sort(); 
```

# 4.总结

list 是⼀种双向链表。每个结点都包含⼀个数据域、⼀个前驱指针 prev 和⼀个后驱指针 next。

由于其链表特性，实现同样的操作，相对于 STL 中的通⽤算法， list 的成员函数通常有更⾼的效率，内部仅需做⼀些指针的操作，因此尽可能选择 list 成员函数。

## 4.1 优点

- 不适⽤连续内存完成动态操作
- 在内部⽅便进行插⼊删除操作。
- 可在两端进行push和pop操作。

## 4.2 缺点

- 不⽀持随机访问，即下标操作和`.at()`。
- 相对于vector占⽤内存多。
